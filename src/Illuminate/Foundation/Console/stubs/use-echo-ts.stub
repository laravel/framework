import { useEffect, useRef } from 'react';
import Echo, { EchoOptions } from 'laravel-echo';
import Pusher from 'pusher-js';

// Define types for Echo channels
interface Channel {
  listen(event: string, callback: (payload: any) => void): Channel;
  stopListening(event: string, callback?: (payload: any) => void): Channel;
}

interface EchoInstance extends Echo<any> {
  channel(channel: string): Channel;
  private(channel: string): Channel;
  leaveChannel(channel: string): void;
}

interface ChannelData {
  count: number;
  channel: Channel;
}

interface Channels {
  [channelName: string]: ChannelData;
}

// Create a singleton Echo instance
let echoInstance: EchoInstance | null = null;
let echoConfig: EchoOptions<any> | null = null;

// Configure Echo with custom options
export const configureEcho = (config: EchoOptions<any>): void => {
  echoConfig = config;
  // Reset the instance if it was already created
  if (echoInstance) {
    echoInstance = null;
  }
};

// Initialize Echo only once
const getEchoInstance = (): EchoInstance | null => {
  if (!echoInstance) {
    if (!echoConfig) {
      console.error('Echo has not been configured. Please call configureEcho() with your configuration options before using Echo.');
      return null;
    }

    // Temporarily add Pusher to window object for Echo initialization
    // This is a compromise - we're still avoiding permanent global namespace pollution
    // by only adding it temporarily during initialization
    const originalPusher = (window as any).Pusher;
    (window as any).Pusher = Pusher;
    
    // Configure Echo with provided config
    echoInstance = new Echo(echoConfig) as EchoInstance;
    
    // Restore the original Pusher value to avoid side effects
    if (originalPusher) {
      (window as any).Pusher = originalPusher;
    } else {
      delete (window as any).Pusher;
    }
  }
  return echoInstance;
};

// Keep track of all active channels
const channels: Channels = {};

// Export Echo instance for direct access if needed
export const echo = (): EchoInstance | null => getEchoInstance();

// Helper functions to interact with Echo
export const subscribeToChannel = (channelName: string, isPrivate = false): Channel | null => {
  const instance = getEchoInstance();
  if (!instance) return null;
  return isPrivate ? instance.private(channelName) : instance.channel(channelName);
};

export const leaveChannel = (channelName: string): void => {
  const instance = getEchoInstance();
  if (!instance) return;
  instance.leaveChannel(channelName);
};

// The main hook for using Echo in React components
export const useEcho = (
  channel: string, 
  event: string | string[], 
  callback: (payload: any) => void, 
  dependencies = [], 
  visibility: 'private' | 'public' = 'private'
) => {
  const eventRef = useRef(callback);

  useEffect(() => {
    // Always use the latest callback
    eventRef.current = callback;

    const channelName = visibility === 'public' ? channel : `${visibility}-${channel}`;
    const isPrivate = visibility === 'private';

    // Reuse existing channel subscription or create a new one
    if (!channels[channelName]) {
      const channelSubscription = subscribeToChannel(channel, isPrivate);
      if (!channelSubscription) return;
      
      channels[channelName] = {
        count: 1,
        channel: channelSubscription,
      };
    } else {
      channels[channelName].count += 1;
    }

    const subscription = channels[channelName].channel;

    const listener = (payload: any) => {
      eventRef.current(payload);
    };

    const events = Array.isArray(event) ? event : [event];

    // Subscribe to all events
    events.forEach((e) => {
      subscription.listen(e, listener);
    });

    // Cleanup function
    return () => {
      events.forEach((e) => {
        subscription.stopListening(e, listener);
      });
      
      if (channels[channelName]) {
        channels[channelName].count -= 1;
        if (channels[channelName].count === 0) {
          leaveChannel(channelName);
          delete channels[channelName];
        }
      }
    };
  }, [...dependencies]); // eslint-disable-line
  
  // Return the Echo instance for additional control if needed
  return {
    echo: getEchoInstance(),
    leaveChannel: () => {
      const channelName = visibility === 'public' ? channel : `${visibility}-${channel}`;
      if (channels[channelName]) {
        channels[channelName].count -= 1;
        if (channels[channelName].count === 0) {
          leaveChannel(channelName);
          delete channels[channelName];
        }
      }
    }
  };
};